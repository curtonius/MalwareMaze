using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour {

	//How much health does the enemy have
	public int health = 20;

	//Where the enemy is, where they were, where they're going
	private Vector3 nextPosition;
	private Vector3 originalPosition;
	private Vector3 lastPostion;

	//Where the enemy is looking, and where they are going to be looking
	private Quaternion nextRotation;
	private Quaternion originalRotation;

	//Does the enemy see the player
	public bool seesPlayer;

	//The Audio sources for the enemy
	public AudioSource drivingSource;
	public AudioSource endDriveSource;
	public AudioSource turningSource;

	private Rigidbody rigidbody;
	private float currentTime;

	// Use this for initialization
	void Start () 
	{
		//Set the default positions/rotations
		originalPosition = nextPosition = transform.position;
		originalRotation = nextRotation = transform.rotation;
	}
	
	// Update is called once per frame
	void Update () 
	{
		//If the enemy is at the next position and they are at the next rotation
		if(transform.position == nextPosition && transform.rotation == nextRotation)
		{
			//Check for the player
			RaycastHit hit;
			Vector3 direction = transform.forward;
			if (Physics.Raycast(transform.position, direction, out hit, 10))
			{
				if(hit.transform.tag != "Projectile")
				{
					//If sees player
					if (hit.transform.tag == "Player")
					{
						seesPlayer = true;

						//Play end drive sound
						if(drivingSource.isPlaying)
						{
							endDriveSource.Play();
						}
						//stop all other sounds
						drivingSource.Stop();
						turningSource.Stop();
					}
					else
					{
						seesPlayer = false;
					}
				}
			}
			else
			{
				seesPlayer = false;
			}

			//If the enemy sees the player, stop here
			if (seesPlayer)
			{
				return;
			}

			//If the enemy does not see the player, do raycast chest for the player to the right and left
			direction = transform.right;
			if (Physics.Raycast(transform.position, direction, out hit, 5) && hit.transform && hit.transform.tag == "Player")
			{
				endDriveSource.Play();
				nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, 90, 0));
				turningSource.Play();
				return;
			}
			else if (Physics.Raycast(transform.position, -direction, out hit, 5) && hit.transform && hit.transform.tag == "Player")
			{
				endDriveSource.Play();
				nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, -90, 0));
				turningSource.Play();
				return;
			}
			//If the enemy still doesn't find the player, then randomly decide where to turn next
			else if (!Physics.Raycast(transform.position, direction, out hit, 5))
			{
				if (Random.value < 0.25f && lastPostion != transform.position+direction*5)
				{
					endDriveSource.Play();
					nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, 90, 0));
					turningSource.Play();
					return;
				}
			}
			else if (!Physics.Raycast(transform.position, -direction, out hit, 5))
			{
				if (Random.value < 0.25f && lastPostion != transform.position - direction * 5)
				{
					endDriveSource.Play();
					nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, -90, 0));
					turningSource.Play();
					return;
				}
			}
			
			//If the enemy has not turned and there is nothing in front of them
			direction = transform.forward;
			if (!Physics.Raycast(transform.position, direction, 5))
			{
				nextPosition = transform.position + direction * 5;
				GameManager.Instance.PlaceCollider(transform.position + direction * 5, tag);
				return;
			}

			endDriveSource.Play();

			//Randomly turn if running into a wall
			if (Random.value < 0.5f)
			{
				direction = transform.right;
				if (!Physics.Raycast(transform.position, direction, 5))
				{
					nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, 90, 0));
				}
				else				
				{
					nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, -90, 0));
				}

				turningSource.Play();
			}
			else
			{
				direction = -transform.right;
				if (!Physics.Raycast(transform.position, direction, 5))
				{
					nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, -90, 0));
				}
				else
				{
					nextRotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, 90, 0));
				}

				turningSource.Play();
			}
		}
		//If the Enemy has not reached the next position, then keep waiting to reach the next position
		else if (transform.position != nextPosition)
		{
			if (!drivingSource.isPlaying)
			{
				drivingSource.Play();
			}
			currentTime += Time.deltaTime;
			transform.position = Vector3.Lerp(originalPosition, nextPosition, currentTime);
			if (currentTime >= 1)
			{
				lastPostion = originalPosition;
				transform.position = nextPosition;
				originalPosition = nextPosition;
				currentTime = 0;
			}
		}
		//if the Enemy has not reaching the next rotation, then keepwaiting to reach the next rotation
		else if (transform.rotation != nextRotation)
		{
			
			currentTime += Time.deltaTime;
			transform.rotation = Quaternion.Lerp(originalRotation, nextRotation, currentTime);
			if (currentTime >= 1)
			{
				transform.rotation = nextRotation;
				originalRotation = nextRotation;
				currentTime = 0;
			}
		}
	}
}
