using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class LevelExit : MonoBehaviour 
{
	//variables to classes to help start the next level
	public MazeGenerator mazeGenerator;
	public TrailSystem trailSystem;
	public MovementScript player;

	//The image to use for finish particles
	public Image finishParticle;

	//The playerOrigin position and original rotation
	private Vector3 playerOrigin;
	private Quaternion playerRotation;

	// Use this for initialization
	void Start () {

		//Set defaults
		playerOrigin = player.transform.position;
		playerRotation = player.transform.rotation;
	}
	

	//Whent he player reaches the end, increase the score and start the finish coroutine
	void OnCollisionEnter(Collision collision)
	{
		if(collision.gameObject.tag != "Player")
		{
			return;
		}

		GameManager.Instance.UpdateScore(100);
		StartCoroutine(Finish());

	}

	IEnumerator Finish()
	{
		float size = 0.05f;

		//Disable projectile launchers/enemies
		ProjectileLauncher[] launchers = FindObjectsOfType<ProjectileLauncher>();
		foreach (ProjectileLauncher launcher in launchers)
		{
			launcher.enabled = false;
			if (launcher.GetComponent<Enemy>())
			{
				launcher.GetComponent<Enemy>().enabled = false;
			}
			if (launcher.GetComponent<MovementScript>())
			{
				launcher.GetComponent<MovementScript>().enabled = false;
			}
		}

		//Spawn a lot of particles to hide the screen
		while (size <= 1)
		{
			for (int i = 0; i < 20; i += 1)
			{
				Image newImage = Instantiate(finishParticle, finishParticle.transform.parent);
				newImage.gameObject.SetActive(true);
				newImage.rectTransform.sizeDelta = new Vector2(finishParticle.rectTransform.sizeDelta.x * size, finishParticle.rectTransform.sizeDelta.y * size);
				newImage.rectTransform.anchoredPosition = new Vector2(Random.Range(-Screen.width / 2, Screen.width / 2), -Screen.height / 2 - Screen.height * size);
				yield return new WaitForEndOfFrame();
			}

			size += 0.05f;
		}

		if (gameObject.name != "TutorialExit")
		{
			//Move the player origin to match the newly created maze
			playerOrigin += new Vector3(0, 0, mazeGenerator.wallSize * 2);
			transform.parent.position += new Vector3(mazeGenerator.wallSize * 2, 0, 0);
			transform.parent.position = new Vector3(transform.parent.position.x, transform.parent.position.y, Random.Range(0, (mazeGenerator.length + 1) * mazeGenerator.wallSize));

			//Refill the battery
			GameManager.Instance.FillBattery();

			player.transform.position = playerOrigin;
			player.transform.rotation = playerRotation;
			player.Clear();

			//Clear trails
			trailSystem.Clear();

			//Generate Maze
			mazeGenerator.Clear();

			mazeGenerator.width += 2;
			mazeGenerator.length += 2;

			mazeGenerator.GenerateMaze();


			//Disable projectile launchers and enemies
			launchers = FindObjectsOfType<ProjectileLauncher>();
			foreach (ProjectileLauncher launcher in launchers)
			{
				launcher.enabled = false;
				if (launcher.GetComponent<Enemy>())
				{
					launcher.GetComponent<Enemy>().enabled = false;
				}
				if (launcher.GetComponent<MovementScript>())
				{
					launcher.GetComponent<MovementScript>().enabled = false;
				}
			}
		}

		if (gameObject.name == "TutorialExit")
		{
			//If it was a tutorial exit then finish the tutorial
			GameManager.Instance.FinishTutorial();
		}
		else
		{
			//Otherwise put more particles
			while (size >= 0.05f)
			{
				for (int i = 0; i < 20; i += 1)
				{
					Image newImage = Instantiate(finishParticle, finishParticle.transform.parent);
					newImage.gameObject.SetActive(true);
					newImage.rectTransform.sizeDelta = new Vector2(finishParticle.rectTransform.sizeDelta.x * size, finishParticle.rectTransform.sizeDelta.y * size);
					newImage.rectTransform.anchoredPosition = new Vector2(Random.Range(-Screen.width / 2, Screen.width / 2), -Screen.height / 2 - Screen.height * size);
					yield return new WaitForEndOfFrame();
				}

				size -= 0.05f;
			}

			yield return new WaitForSeconds(2);

			//Re-enable projectile launchers and enemies
			launchers = FindObjectsOfType<ProjectileLauncher>();
			foreach (ProjectileLauncher launcher in launchers)
			{
				launcher.enabled = true;
				if (launcher.GetComponent<Enemy>())
				{
					launcher.GetComponent<Enemy>().enabled = true;
				}
				if (launcher.GetComponent<MovementScript>())
				{
					launcher.GetComponent<MovementScript>().enabled = true;
				}
			}
		}
		yield return null;
	}
}
