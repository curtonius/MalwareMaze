using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MazeGenerator : MonoBehaviour
{
    public static MazeGenerator Instance;

    //Maze dimensions
    public int width = 10;
    public int length = 10;

    //Wall size to multiply by
    public float wallSize = 5;

    //Objects to use for generation
    public GameObject wall;
    public GameObject pillar;
    public GameObject floor;
    public GameObject enemy;

    //Enemy list
    private List<GameObject> enemies = new List<GameObject>();

    //List of walls by position
    private Dictionary<Vector3, GameObject> CellWallsTop = new Dictionary<Vector3, GameObject>();
    private Dictionary<Vector3, GameObject> CellWallsLeft = new Dictionary<Vector3, GameObject>();

    //Objects that aren't really part of the maze generation but more for world generation
    private List<GameObject> otherBlocks = new List<GameObject>();

    //List of positions horizontally down the rows to determine how far this section of the maze goes
    private List<Vector3> RunSet = new List<Vector3>();


    // Start is called before the first frame update
    void Start()
    {
        Instance = this;
        GenerateMaze();
    }


    //Get rid of everything in the maze
    public void Clear()
    {
        foreach (GameObject wall in CellWallsTop.Values)
        {
            Destroy(wall);
        }
        foreach (GameObject wall in CellWallsLeft.Values)
        {
            Destroy(wall);
        }
        foreach (GameObject wall in otherBlocks)
        {
            Destroy(wall);
        }
        foreach(GameObject tank in enemies)
        {
            Destroy(tank);
        }
        CellWallsTop = new Dictionary<Vector3, GameObject>();
        CellWallsLeft = new Dictionary<Vector3, GameObject>();
        otherBlocks = new List<GameObject>();
        enemies = new List<GameObject>();
    }

    //Generate the maze
    public void GenerateMaze()
    {
        //Go through width/length to create cells
        for (int x = 0; x < width; x++)
        {
            for (int z = 0; z < length; z++)
            {
                GameObject newPillar = Instantiate(pillar, transform);
                newPillar.transform.position = new Vector3(x * wallSize - 2.5f, 2.5f, z * wallSize - 2.5f);
                otherBlocks.Add(newPillar);

                if (z != length-1)
                {
                    GameObject UpWall = Instantiate(wall,transform);
                    UpWall.transform.position = new Vector3(x * wallSize, 2.5f, z * wallSize + wallSize / 2);
                    UpWall.transform.Rotate(0, 90, 0);
                    CellWallsTop.Add(new Vector3(x, 0, z), UpWall);
                }
                else
                {
                    GameObject newPillar2 = Instantiate(pillar, transform);
                    newPillar2.transform.position = new Vector3(x * wallSize - wallSize/2, 2.5f, z * wallSize + wallSize/2);
                    otherBlocks.Add(newPillar2);
                }

                if (x != 0)
                {
                    GameObject SideWall = Instantiate(wall, transform);
                    SideWall.transform.position = new Vector3(x * wallSize - wallSize / 2, 2.5f, z * wallSize);
                    CellWallsLeft.Add(new Vector3(x, 0, z), SideWall);
                }
                else
                {
                    GameObject newPillar2 = Instantiate(pillar, transform);
                    newPillar2.transform.position = new Vector3(width*wallSize - 2.5f, 2.5f, z * wallSize - 2.5f);
                    otherBlocks.Add(newPillar2);
                }
            }
        }

        //Create a floor
        GameObject floorInstance = Instantiate(floor, transform);
        floorInstance.transform.localScale = new Vector3(wallSize * width, 1, wallSize * length);
        floorInstance.transform.position = new Vector3(wallSize * (width/2)-(wallSize/2), -0.5f, wallSize * (length / 2) - (wallSize/2));
        otherBlocks.Add(floorInstance);


        //Create walls around the perimeter 
        float len = (wallSize * length) / 2;
        float wid = (wallSize * width) / 2;

        GameObject LeftWall = Instantiate(wall, transform);
        LeftWall.transform.parent = transform;
        LeftWall.transform.localScale = new Vector3(1, 1, length);
        LeftWall.transform.position = new Vector3(-(wallSize/2), 2.5f, len - (wallSize/2));
        otherBlocks.Add(LeftWall);

        GameObject RightWall = Instantiate(wall, transform);
        RightWall.transform.parent = transform;
        RightWall.transform.localScale = new Vector3(1, 1, length);
        RightWall.transform.position = new Vector3(wallSize*width - (wallSize/2), 2.5f, len - (wallSize/2));
        otherBlocks.Add(RightWall);

        GameObject BottomWall = Instantiate(wall, transform);
        BottomWall.transform.parent = transform;
        BottomWall.transform.Rotate(0, 90, 0);
        BottomWall.transform.localScale = new Vector3(1, 1, width);
        BottomWall.transform.position = new Vector3(wid - (wallSize/2), 2.5f, -(wallSize/2));
        otherBlocks.Add(BottomWall);

        GameObject TopWall = Instantiate(wall, transform);
        TopWall.transform.parent = transform;
        TopWall.transform.Rotate(0, 90, 0);
        TopWall.transform.localScale = new Vector3(1, 1, width);
        TopWall.transform.position = new Vector3(wid - (wallSize/2), 2.5f, wallSize * length - (wallSize/2));
        otherBlocks.Add(TopWall);

        //Destroy walls to open cells up to the rest of the maze using the sidewinder method https://weblog.jamisbuck.org/2011/2/3/maze-generation-sidewinder-algorithm
        for (int x = 0; x < width; x++)
        {
            for (int z = 0; z < length; z++)
            {
                if (x == 0)
                {
                    if (z != length - 1)
                    {
                        Destroy(CellWallsTop[new Vector3(x, 0, z)]);
                    }
                }
                else
                {
                    float chance = Random.value;
                    RunSet.Add(new Vector3(x, 0, z));
                    if (chance < 0.5f && z != length-1)
                    {
                        Destroy(CellWallsTop[new Vector3(x, 0, z)]);
                    }
                    else
                    {
                        if (RunSet.Count > 1)
                        {
                            int index = Random.Range(0, RunSet.Count);
                            Destroy(CellWallsLeft[RunSet[index]]);
                            RunSet.Clear();
                        }
                        else
                        {
                            Destroy(CellWallsLeft[new Vector3(x, 0, z)]);
                            RunSet.Clear();
                        }
                    }
                }
            }
        }

        //Add enemies to the maze after it is created
        AddEnemies();
    }

    void AddEnemies()
    {
        //Add enemies to random positions that have not already been taken up
        int numberOfEnemies = (int)(Mathf.Floor(width / 10) * 5.0f);
        List<Vector3> unavailableSlots = new List<Vector3>();

        for(int i=0; i<numberOfEnemies; i+=1)
        {
            float x = wallSize * Random.Range(1, width);
            float z = wallSize * Random.Range(0, length);

            while (unavailableSlots.Contains(new Vector3(x, 0.5f, z)))
            {
                x = wallSize * Random.Range(1, width);
                z = wallSize * Random.Range(0, length);
            }

            unavailableSlots.Add(new Vector3(x, 0.5f, z));
            GameObject tank = Instantiate(enemy, new Vector3(x, 0.5f, z), Quaternion.identity);
            enemies.Add(tank);
        }
    }
}