using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

public class TrailSystem : MonoBehaviour {

	//What the trail is following
	public Transform trailFollow;

	//How wide the trail should be
	public float trailWidth = 1;

	//The last position/direction of the trailFollow
	private Vector3 lastPosition;
	private Vector3 lastDirection;

	private MeshFilter meshFilter;

	//Information for the trail renderer
	List<Vector3> newVertices = new List<Vector3>();
	List<int> newTriangles = new List<int>();
	List<Vector3> newNormals = new List<Vector3>();

	Vector3 rightBackPoint;
	Vector3 leftBackPoint;
	int leftIndex;
	int rightIndex;

	void Start()
	{
		meshFilter = GetComponent<MeshFilter>();
		if(!meshFilter)
		{
			meshFilter = gameObject.AddComponent<MeshFilter>();
		}

		if(meshFilter.mesh == null)
		{
			meshFilter.mesh = new Mesh();
		}

		meshFilter.mesh.MarkDynamic();

		lastPosition = trailFollow.position;
		lastDirection = trailFollow.forward;
	}
	
	//Restart mesh
	public void Clear()
	{
		newVertices = new List<Vector3>();
		newTriangles = new List<int>();
		newNormals = new List<Vector3>();

		meshFilter.mesh.Clear();

		lastPosition = trailFollow.position;
	}

	// Update is called once per frame
	void Update () 
	{
		Mesh mesh = meshFilter.mesh;

		//Create a new part of the trail if the trailFollow has moved
		if(trailFollow.position != lastPosition)
		{
			Vector3 direction = (lastPosition - trailFollow.position).normalized;

			Vector3 right = Vector3.Cross(direction, trailFollow.up)* trailWidth;

			if (newVertices.Count == 0)
			{
				rightBackPoint = lastPosition - new Vector3(0, 0.9f, 0) + right;
				leftBackPoint = lastPosition - new Vector3(0, 0.9f, 0) - right;

				Vector3 rightFrontPoint = trailFollow.position - new Vector3(0, 0.9f, 0) + right;
				Vector3 leftFrontPoint = trailFollow.position - new Vector3(0, 0.9f, 0) - right;

				newVertices.Add(rightBackPoint);
				newVertices.Add(leftBackPoint);
				newVertices.Add(rightFrontPoint);
				newVertices.Add(leftFrontPoint);

				rightIndex = 2;
				leftIndex = 3;

				newTriangles.Add(1);
				newTriangles.Add(3);
				newTriangles.Add(2);

				newTriangles.Add(2);
				newTriangles.Add(0);
				newTriangles.Add(1);

				newNormals.Add(trailFollow.up);
				newNormals.Add(trailFollow.up);
				newNormals.Add(trailFollow.up);
				newNormals.Add(trailFollow.up);
			}
			else
			{
				if (lastDirection != direction)
				{
					rightBackPoint = lastPosition - new Vector3(0, 0.9f, 0) + right;
					leftBackPoint = lastPosition - new Vector3(0, 0.9f, 0) - right;

					Vector3 rightFrontPoint = trailFollow.position - new Vector3(0, 0.9f, 0) + right;
					Vector3 leftFrontPoint = trailFollow.position - new Vector3(0, 0.9f, 0) - right;

					newVertices.Add(rightBackPoint);
					newVertices.Add(leftBackPoint);
					newVertices.Add(rightFrontPoint);
					newVertices.Add(leftFrontPoint);

					rightIndex += 2;
					leftIndex += 2;

					int nextRight = rightIndex + 2;
					int nextLeft = leftIndex + 2;

					newTriangles.Add(nextLeft);
					newTriangles.Add(nextRight);
					newTriangles.Add(rightIndex);

					newTriangles.Add(rightIndex);
					newTriangles.Add(leftIndex);
					newTriangles.Add(nextLeft);

					leftIndex = nextLeft;
					rightIndex = nextRight;

					newNormals.Add(trailFollow.up);
					newNormals.Add(trailFollow.up);
					newNormals.Add(trailFollow.up);
					newNormals.Add(trailFollow.up);
				}
				else
				{
					newVertices[rightIndex] = new Vector3(trailFollow.position.x, 0.1f, trailFollow.position.z) + right;
					newVertices[leftIndex] = new Vector3(trailFollow.position.x, 0.1f, trailFollow.position.z) - right;
				}
			}

			mesh.vertices = newVertices.ToArray();
			mesh.triangles = newTriangles.ToArray();
			mesh.normals = newNormals.ToArray();

			//MeshUtility.Optimize(mesh);
			mesh.RecalculateBounds();
			mesh.RecalculateNormals();

			lastDirection = direction;
			lastPosition = trailFollow.position;
		}
	}
}
