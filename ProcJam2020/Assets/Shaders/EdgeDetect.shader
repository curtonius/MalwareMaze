// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Example/EdgeDetect"
{
	Properties
	{
		_MainTex("Texture", 2D) = "white" {}
		_DamageColor("Damage Color", Color) = (1,1,1,1)
	}
	
	SubShader
	{
		// No culling or depth
		Cull Off ZWrite Off ZTest Always

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			#include "UnityCG.cginc"

			sampler2D _MainTex;
			uniform float4  _MainTex_TexelSize;
			uniform float4 _OutlineColor;
			uniform float4 _DamageColor;
			uniform float4 _MainColor;
			uniform float _LineThickness;
			uniform float _ScanSpeed;
			uniform float _DistortionX;
			uniform float _DistortionY;
			uniform int _Damaged;
			half4 _MainTex_ST;

			struct appdata
			{
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
			};

			struct v2f
			{
				float2 uv : TEXCOORD0;
				float4 vertex : SV_POSITION;
			};

			v2f vert(appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.uv = v.uv;
				return o;
			}


			float GetDist(fixed4 first, fixed4 second)
			{
				return distance(first,second);
			}

			bool CheckForDifferentColor(float2 uv,float thickness)
			{
				fixed4 currentColor = tex2D(_MainTex, uv);

				float width = (float)_MainTex_TexelSize.x;
				float height = (float)_MainTex_TexelSize.y;

				fixed4 topColor = currentColor;
				fixed4 leftColor = currentColor;

				bool isDifferent = false;
				for (int i = 0; i < thickness; i+=1)
				{
					topColor = tex2D(_MainTex, uv + float2(0, width * i));
					leftColor = tex2D(_MainTex, uv + float2(height * i, 0));
				
					if (currentColor.r < 0.25f && currentColor.g < 0.25f && currentColor.b < 0.25f)
					{
						return false;
					}
					else if (topColor.r < 0.25f && topColor.g < 0.25f && topColor.b < 0.25f)
					{
						return false;
					}
					else if (leftColor.r < 0.25f && leftColor.g < 0.25f && leftColor.b < 0.25f)
					{
						return false;
					}
					else if (currentColor.r >= 0.8f && currentColor.g == 0 && currentColor.b == 0)
					{
						return false;
					}
					else if (topColor.r >= 0.8f && topColor.g == 0 && topColor.b == 0)
					{
						return false;
					}
					else if (leftColor.r >= 0.8f && leftColor.g == 0 && leftColor.b == 0)
					{
						return false;
					}
					else
					{
						if (GetDist(currentColor, topColor) > 0.2f)
							return true;
						if (GetDist(currentColor, leftColor) > 0.2f)
							return true;
					}
				}

				return false;
			}

			float2 curveRemapUV(float2 uv)
			{
				// as we near the edge of our screen apply greater distortion using a cubic function
				uv = (uv * 2) - float2(1,1);
				float2 offset = abs(uv.yx) / float2(_DistortionX, _DistortionY);
				uv = uv + uv * offset * offset;
				uv = uv * 0.5 + 0.5;
				return uv;
			}

			fixed4 frag(v2f i) : SV_Target
			{

				float2 uv = i.uv;
				fixed4 col = tex2D(_MainTex, curveRemapUV(i.uv));
				float2 remappedUV = curveRemapUV(i.uv);

				bool doIt = false;

				for (int x = 0; x < _LineThickness; ++x)
				{
					if (CheckForDifferentColor(curveRemapUV(i.uv), x))
					{
						doIt = true;
					}
				}

				if (doIt)
				{
					if (col.r < 0.05f && col.g < 0.05f && col.b < 0.05f)
					{
						col = float4(0, 0, 0, 1);
					}
					else if (col.r == 1 && col.g == 0 && col.b == 0)
					{

					}
					else
					{
						col = _OutlineColor;
					}
				}
				else
				{
					if (col.r < 0.35f && col.g < 0.35f && col.b < 0.35f)
					{
						if (col.r < 0.05f && col.g < 0.05f && col.b < 0.05f)
						{
							col = float4(0, 0, 0, 1);
						}
						else
						{
							col = float4(0.3f, 0.3f, 0.3f, 1);
						}
					}
					else if (col.r > 0.8f && col.g > 0.8f && col.b == 0)
					{
						col = float4(1, 1, 0, 1);
					}
					else if (col.r == 1 && col.g == 0 && col.b == 0)
					{

					}
					else if (col.r == 0 && col.g == 1 && col.b == 0)
					{
						col = _MainColor *= 0.5f;
					}
					else
					{
						col = _MainColor;
					}
				}

				//Scanline time
				if (floor(i.vertex.y + 5 + (_Time.y*_ScanSpeed)) % 10 == 0)
				{
					col = float4(0, 0, 0, 1);
				}

				if (remappedUV.x < 0.0 || remappedUV.y < 0.0 || remappedUV.x > 1.0 || remappedUV.y > 1.0) {
					col = float4(0.0, 0.0, 0.0, 0.0);
				}
				else
				{
					col.a = 1;
				}

				if (_Damaged == 1)
				{
					col *= _DamageColor;
				}

				return col;
			}
			ENDCG
		}
	}
}
